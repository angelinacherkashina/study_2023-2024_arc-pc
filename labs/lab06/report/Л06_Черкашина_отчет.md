---
## Front matter
title: "Отчёт по лабораторной работе №6"
subtitle: "Дисциплина: архитектура компьютера"
author: "Черкашина Ангелина Максимовна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Цель данной лабораторной работы - освоение арифметических инструкций языка ассемблера NASM.

# Задание

1. Символьные и численные данные в NASM
2. Выполнение арифметических операций в NASM
3. Выполнение заданий для самостоятельной работы

# Теоретическое введение

Большинство инструкций на языке ассемблера требуют обработки операндов. Адрес операнда предоставляет место, где хранятся данные, подлежащие обработке. Это могут быть данные хранящиеся в регистре или в ячейке памяти. 
- Регистровая адресация – операнды хранятся в регистрах и в команде используются имена этих регистров, например: mov ax,bx.
- Непосредственная адресация – значение операнда задается непосредственно в команде, Например: mov ax,2.
- Адресация памяти – операнд задает адрес в памяти. В команде указывается символическое обозначение ячейки памяти, над содержимым которой требуется выполнить операцию.
Ввод информации с клавиатуры и вывод её на экран осуществляется в символьном виде. Кодирование этой информации производится согласно кодовой таблице символов ASCII. ASCII – сокращение от American Standard Code for Information Interchange (Американский стандартный код для обмена информацией). Согласно стандарту ASCII каждый символ кодируется одним байтом.
Среди инструкций NASM нет такой, которая выводит числа (не в символьном виде). Поэтому, например, чтобы вывести число, надо предварительно преобразовать его цифры в ASCII-коды этих цифр и выводить на экран эти коды, а не само число. Если же выводить число на экран непосредственно, то экран воспримет его не как число, а как последовательность ASCII-символов – каждый байт числа будет воспринят как один ASCII-символ – и выведет на экран эти символы.
Аналогичная ситуация происходит и при вводе данных с клавиатуры. Введенные данные будут представлять собой символы, что сделает невозможным получение корректного результата при выполнении над ними арифметических операций.
Для решения этой проблемы необходимо проводить преобразование ASCII символов в числа и обратно.

# Выполнение лабораторной работы
## Символьные и численные данные в NASM

С помощью команды mkdir создаю каталог для программам данной лабораторной работы, перехожу в созданный каталог с помощьб cd (рис. @fig:001).

![Создание директории](image1/1.png){#fig:001 width=70%}

С помощью команды touch создаю файл lab6-1.asm (рис. @fig:002).

![Создание файла](image1/2.png){#fig:002 width=70%}

С помощью команды cp копирую в текущий каталог файл in_out.asm, т.к. он будет использоваться в других программах (рис. @fig:003).

![Создание копии файла](image1/3.png){#fig:003 width=70%}

Открываю созданный файл lab6-1.asm, вставляю в него программу вывода значения регистра eax (рис. @fig:004).

![Редактирование файла](image1/4.png){#fig:004 width=70%}

Создаю исполняемый файл программы и запускаю его (рис. @fig:005). Вывод программы: символ j. Это происходит потому, что код символа 6 равен 00110110 в двоичном представлении (или 54 в десятичном представлении), а код символа 4 – 00110100 (52). Команда add eax,ebx запишет в регистр eax сумму кодов – 01101010 (106), что в свою очередь является кодом символа j по кодовой таблице ASCII.

![Запуск исполняемого файла](image1/5.png){#fig:005 width=70%}

Изменяю текст программы и вместо символов записываю в регистры числа, т.е. исправляю символы "6" и "4" на числа 6 и 4 (рис. @fig:006).

![Изменение текста программы](image1/6.png){#fig:006 width=70%}

Создаю новый исполняемый файл программы и запускаю его. Теперь вывелся символ с кодом 10, согласно таблице ASCII код 10 соответствует символу перевода строки. Поэтому этот символ не отображается при выводе на экран (рис. @fig:007).

![Запуск нового исполняемого файла](image1/7.png){#fig:007 width=70%}

Создаю в каталоге ~/work/arch-pc/lab06 новый файл lab6-2.asm с помощью команды touch (рис. @fig:008).

![Создание файла](image1/8.png){#fig:008 width=70%}

Ввожу в созданный файл текст другой программы для вывода значения регистра eax (рис. @fig:009).

![Редактирование файла](image1/9.png){#fig:009 width=70%}

Создаю и запускаю исполняемый файл lab6-2 (рис. @fig:010). В результате работы программы получается число 106. В данном случае, как и в первом, команда add складывает коды символов ‘6’ и ‘4’ (54+52=106). Однако, в отличии от программы файла lab6-1, функция iprintLF позволяет вывести число, а не символ, кодом которого является это число.

![Запуск исполняемого файла](image1/10.png){#fig:010 width=70%}

Аналогично предыдущей программе корректирую текст программы файла lab6-2 и меняю символы на числа (исправляю символы "6" и "4" на числа 6 и 4) (рис. @fig:011).

![Изменение текста программы](image1/11.png){#fig:011 width=70%}

Создаю и запускаю новый исполняемый файл. Теперь программа складывает не соответствующие символам коды в системе ASCII, а сами числа, поэтому вывод 10 (рис. @fig:012).

![Запуск нового исполняемого файла](image1/12.png){#fig:012 width=70%}

Заменяю в тексте программы функцию iprintLF на iprint (рис. @fig:013).

![Изменение текста программы](image1/13.png){#fig:013 width=70%}

Создаю и запускаю новый исполняемый файл (рис. @fig:014). Функция iprint не добавляет к выводу символ переноса строки, в отличие от iprintLF.

![Запуск нового исполняемого файла](image1/14.png){#fig:014 width=70%}

## Выполнение арифметических операций в NASM

С помощью команды touch создаю файл lab6-3.asm в каталоге ~/work/arch-pc/lab06 (рис. @fig:015).

![Создание файла](image1/15.png){#fig:015 width=70%}

Ввожу в созданный файл текст программы вычисления значения выражения f(x) = (5 * 2 + 3)/3 (рис. @fig:016).

![Редактирование файла](image1/16.png){#fig:016 width=70%}

Создаю исполняемый файл и запускаю его (рис. @fig:017).

![Запуск исполняемого файла](image1/17.png){#fig:017 width=70%}

Изменяю текст программы так, чтобы она вычисляла значение выражения f(x) = (4 * 6 + 2)/5 (рис. @fig:018).

![Изменение программы](image1/18.png){#fig:018 width=70%}

Создаю новый исполняемый файл и запускаю его. Проверяю его работу, посчитав значение выражения самостоятельно. Убеждаюсь, что программа сработала верно (рис. @fig:019).

![Запуск нового исполняемого файла](image1/19.png){#fig:019 width=70%}

Создаю файл variant.asm в каталоге ~/work/arch-pc/lab06 с помощью команды touch (рис. @fig:020).

![Создание файла](image1/20.png){#fig:020 width=70%}

Ввожу в созданный файл текст программы вычисления варианта задания по номеру студенческого билета (рис. @fig:021).

![Редактирование файла](image1/21.png){#fig:021 width=70%}

Создаю и запускаю исполняемый файл. Ввожу номер своего студенческого билета с клавиатуры, программа выводит мой вариант - 11. Проверяю результат работы программы, вычислив номер своего варианта аналитически. Убеждаюсь, что программа сработала верно (рис. @fig:022).

![Запуск исполняемого файла](image1/22.png){#fig:022 width=70%}

### Ответы на вопросы по программе

1. Какие строки листинга 6.4 отвечают за вывод на экран сообщения ‘Ваш вариант:’?

За вывод сообщения "Ваш вариант" отвечают следующие строки кода:

```NASM

mov eax,rem
call sprint
```

2. Для чего используется следующие инструкции?

```NASM

mov ecx, x
mov edx, 80
call sread

```

Инструкция mov ecx, x используется, чтобы положить адрес вводимой строки x в регистр ecx; mov edx, 80 - запись в регистр edx длины вводимой строки; call sread - вызов подпрограммы из внешнего файла, обеспечивающей ввод сообщения с клавиатуры.

3. Для чего используется инструкция “call atoi”?

Инструкция call atoi используется для вызова подпрограммы из внешнего файла, которая преобразует ASCII-код символа в целое число и записывает результат в регистр eax.

4. Какие строки листинга 6.4 отвечают за вычисления варианта?

За вычисления варианта отвечают следующие строки кода:

```NASM

xor edx,edx ; обнуление edx для корректной работы div
mov ebx,20 ; ebx = 20
div ebx ; eax = eax/20, edx - остаток от деления
inc edx ; edx = edx + 1

```

5. В какой регистр записывается остаток от деления при выполнении инструкции “div ebx”?

При выполнении инструкции div ebx остаток от деления записывается в регистр edx.

6. Для чего используется инструкция “inc edx”?

Инструкция inc edx увеличивает значение регистра edx на 1.

7. Какие строки листинга 6.4 отвечают за вывод на экран результата вычислений?

За вывод на экран результата вычислений отвечают следующие строки:

```NASM

mov eax,edx
call iprintLF
```

## Выполнение заданий для самостоятельной работы

Создаю файл lab6-4.asm с помощью команды touch (рис. @fig:023).

![Создание файла](image1/23.png){#fig:023 width=70%}

Открываю созданный файл для редактирования, ввожу в него текст программы для вычисления значения выражения 10*(x + 1)-10 (вариант 11) (рис. @fig:024).

![Написание программы](image1/24.png){#fig:024 width=70%}

Создаю и запускаю исполняемый файл. Ввожу значение x1 = 1 с клавиатуры. В результате выполнения программы получаю число 10 (рис. @fig:025). Проверяю результат работы программы, подсчитав значение выражения самостоятельно. Убеждаюсь, что программа сработала верно.

![Запуск исполняемого файла](image1/25.png){#fig:025 width=70%}

Снова запускаю исполняемый файл для проверки работы программы с другим значением на вводе (x2 = 7). Программа выводит результат 70 (рис. @fig:026). Проверяю результат работы программы, подсчитав значение выражения самостоятельно. Убеждаюсь, что программа сработала верно.

![Запуск исполняемого файла](image1/26.png){#fig:026 width=70%}

Листинг 4.1. Программа для вычисления значения выражения 10*(x + 1)-10: 

```NASM

%include 'in_out.asm' ; подключение внешнего файла

 SECTION .data
 msg: DB 'Введите значение переменной x: ',0
 rem: DB 'Результат вычислений: ',0
 
 SECTION .bss
 x: RESB 80 ; Переменная, значение которой вводится с клавиатуры
 
 SECTION .text
 GLOBAL _start
  _start:
  
  ; ---- Вычисление выражения
  mov eax, msg
  call sprintLF

  mov ecx, x
  mov edx, 80
  call sread

  mov eax,x ; вызов подпрограммы преобразования
  call atoi ; ASCII кода в число, `eax=x

  add eax,1 ; eax = eax+1 = x+1
  mov ebx,10 ; ebx = 10
  mul ebx ; eax = eax*ebx = 10*(x+1)
  add eax,-10 ; eax = eax-10 = 10*(x+1)-10
  mov edi,eax ; запись результата вычисления в 'edi'

  ; ---- Вывод результата на экран
  mov eax,rem ; вызов подпрограммы печати
  call sprint ; вызов сообщения 'Результат: '
  mov eax,edi ; вызов подпрограммы печати значения
  call iprintLF ; из 'edi' в виде символов

  call quit ; вызов подпрограммы завершения


```
  
# Выводы

При выполнении данной лабораторной работы я освоила арифметические инструкции языка ассемблера NASM.

# Список литературы{.unnumbered}

1. Архитектура ЭВМ
2. Таблица ASCII
